<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html lang="en">
<head><meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<title>Thinking in Java, 3rd ed. Revision 4.0: B: Java Programming Guidelines</title>
<!-- OS LIGHT & DARK MODE -->
<style>
   /* :root {
     color-scheme: light dark;
   } */
   body {
      color: silver;
      font-family: 'Lucida Sans', 'Lucida Sans Regular', 'Lucida Grande', 'Lucida Sans Unicode', Geneva, Verdana, sans-serif;
      /* font-family: 'Gill Sans', 'Gill Sans MT', Calibri, 'Trebuchet MS', sans-serif; */
      /* font-family: Cambria, Cochin, Georgia, Times, 'Times New Roman', serif; */
      font-size: larger;
      background-color: black;
   }
</style>
<body>
   <CENTER>     <a href="http://www.MindView.net">     <img src="mindview.gif" alt="MindView Inc." BORDER = "0"></a>          <h2>Thinking in Java, 3<sup>rd</sup> ed. Revision 4.0</h2>     
   </CENTER> 
      <!-- <br>     [ <a href="README.txt">Viewing Hints</a> ]     [ <a href="http://www.mindview.net/Books/TIJ/">Book Home Page</a> ]     [ <a href="http://www.mindview.net/Etc/MailingList.html">Free Newsletter</a> ] <br>     [ <a href="http://www.mindview.net/Seminars">Seminars</a> ]     [ <a href="http://www.mindview.net/CDs">Seminars on CD ROM</a> ]     [ <a href="http://www.mindview.net/Services">Consulting</a> ] <br><br>
<div align="CENTER"><a href="TIJ319.htm" target="RightFrame"><img src="./prev.gif" alt="Previous " border="0"></a>
<a href="TIJ321.htm" target="RightFrame"><img src="./next.gif" alt="Next " border="0"></a>

<a href="TIJ3_t.htm"><img src="./first.gif" alt="Title Page " border="0"></a>
<a href="TIJ3_i.htm"><img src="./index.gif" alt="Index " border="0"></a>
<a href="TIJ3_c.htm"><img src="./contents.gif" alt="Contents " border="0"></a>
</div> -->
<hr>

<h1>
<a name="_Toc375545509"></a><a name="_Toc24272657"></a><a name="_Toc24776012"></a><a name="Heading25755"></a>B:
Java Programming Guidelines</h1>
<p class="Intro">This appendix contains suggestions to help guide you in performing low-level program design and in writing code.<br></p>
<p><a name="Index2208"></a><a name="Index2209"></a><a name="Index2210"></a><a name="Index2211"></a>Naturally, these are guidelines and not rules. The idea is to use them as inspirations and to remember that there are occasional situations where they should be bent or broken. <br></p>
<h2>
<a name="_Toc24776013"></a><a name="Heading25758"></a>Design</h2>
<ol>
<li><b>Elegance always pays off</b>. In the short term it might seem like it
takes much longer to come up with a truly graceful solution to a problem, but
when it works the first time and easily adapts to new situations instead of
requiring hours, days, or months of struggle, you&#146;ll see the rewards (even
if no one can measure them). Not only does it give you a program that&#146;s
easier to build and debug, but it&#146;s also easier to understand and
maintain, and that&#146;s where the financial value lies. This point can take
some experience to understand, because it can appear that you&#146;re not being
productive while you&#146;re making a piece of code elegant. Resist the urge to
hurry; it will only slow you down. <a
href="mailto:TIJ3@MindView.net?Subject=[TIJ3]AppendC_2835" title="Send BackTalk
Comment"></a></li>
<li><b>First make it work, then make it fast</b>. This is true even if you are
certain that a piece of code is really important and that it will be a principal
bottleneck in your system. Don&#146;t do it. Get the system going first with as
simple a design as possible. Then if it isn&#146;t going fast enough, profile
it. You&#146;ll almost always discover that &#147;your&#148; bottleneck
isn&#146;t the problem. Save your time for the really important stuff. <a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]AppendC_2836"
title="Send BackTalk Comment"></a></li>
<li><b>Remember the &#147;divide and conquer&#148; principle</b>. If the
problem you&#146;re looking at is too confusing, try to imagine what the basic
operation of the program would be, given the existence of a magic
&#147;piece&#148; that handles the hard parts. That &#147;piece&#148; is an
object&#151;write the code that uses the object, then look at the object and
encapsulate <i>its</i> hard parts into other objects, etc. <a
href="mailto:TIJ3@MindView.net?Subject=[TIJ3]AppendC_2837" title="Send BackTalk
Comment"></a></li>
<li><b>Separate the class creator from the class user (<i>client
programmer</i>)</b>. The class user is the &#147;customer&#148; and
doesn&#146;t need or want to know what&#146;s going on behind the scenes of
the class. The class creator must be the expert in class design and write the
class so that it can be used by the most novice programmer possible, yet still
work robustly in the application. Think of the class as a <i>service provider
</i>for other classes. Library use will be easy only if it&#146;s transparent.
<a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]AppendC_2838"
title="Send BackTalk Comment"></a></li>
<li><b>When you create a class, attempt to make your names so clear that
comments are unnecessary</b>. Your goal should be to make the client
programmer&#146;s interface conceptually simple. To this end, use method
overloading when appropriate to create an intuitive, easy-to-use interface.
<a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]AppendC_2839"
title="Send BackTalk Comment"></a></li>
<li><b>Your analysis and design must produce, at minimum, the classes in your
system, their public interfaces, and their relationships to other classes,
especially base classes</b>. If your design methodology produces more than that,
ask yourself if all the pieces produced by that methodology have value over the
lifetime of the program. If they do not, maintaining them will cost you. Members
of development teams tend not to maintain anything that does not contribute to
their productivity; this is a fact of life that many design methods don&#146;t
account for. <a
href="mailto:TIJ3@MindView.net?Subject=[TIJ3]AppendC_2840" title="Send BackTalk
Comment"></a></li>
<li><b>Automate everything</b>.<b> </b>Write the test code first (before you
write the class), and keep it with the class. Automate the running of your tests
through a build tool&#151;you&#146;ll probably want to use Ant, the defacto
standard Java build tool. This way, any changes can be automatically verified by
running the test code, and you&#146;ll immediately discover errors. Because you
know that you have the safety net of your test framework, you will be bolder
about making sweeping changes when you discover the need. Remember that the
greatest improvements in languages come from the built-in testing provided by
type checking, exception handling, etc., but those features take you only so
far. You must go the rest of the way in creating a robust system by filling in
the tests that verify features that are specific to your class or program. 
<a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]AppendC_2841"
title="Send BackTalk Comment"></a></li>
<li><b>Write the test code first (before you write the class) in order to verify
that your class design is complete</b>. If you can&#146;t write test code, you
don&#146;t know what your class looks like. In addition, the act of writing the
test code will often flush out additional features or constraints that you need
in the class&#151;these features or constraints don&#146;t always appear
during analysis and design. Tests also provide example code showing how your
class can be used. <a
href="mailto:TIJ3@MindView.net?Subject=[TIJ3]AppendC_2842" title="Send BackTalk
Comment"></a></li>
<li><b>All software design problems can be simplified by introducing an extra
level of conceptual indirection</b><i>.</i> This fundamental rule of software
engineering<sup><a name="fnB122" href="#fn122">[122]</a></sup><a name="Index2212"></a>
is the basis of abstraction, the primary feature of object-oriented programming.
In OOP, we could also say this as: &#147;If your code is too complicated, make
more objects.&#148; <a
href="mailto:TIJ3@MindView.net?Subject=[TIJ3]AppendC_2843" title="Send BackTalk
Comment"></a></li>
<li><b>An indirection should have a meaning </b>(in concert with guideline 9).
This meaning can be something as simple as &#147;putting commonly used code in
a single method.&#148; If you add levels of indirection (abstraction,
encapsulation, etc.) that don&#146;t have meaning, it can be as bad as not
having adequate indirection. <a
href="mailto:TIJ3@MindView.net?Subject=[TIJ3]AppendC_2844" title="Send BackTalk
Comment"></a></li>
<li><b>Make classes as atomic as possible</b>. Give each class a single, clear
purpose&#151;a cohesive service that it provides to other classes. If your
classes or your system design grows too complicated, break complex classes into
simpler ones. The most obvious indicator of this is sheer size; if a class is
big, chances are it&#146;s doing too much and should be broken up.<br>Clues to
suggest redesign of a class are:<br>1) A complicated switch statement: consider
using polymorphism. <br>2) A large number of methods that cover broadly
different types of operations: consider using several classes.<br>3) A large
number of member variables that concern broadly different characteristics:
consider using several classes. <br>4) Other suggestions can be found in
<i>Refactoring: Improving the Design of Existing Code</i> by Martin Fowler
(Addison-Wesley 1999). <a
href="mailto:TIJ3@MindView.net?Subject=[TIJ3]AppendC_2845" title="Send BackTalk
Comment"></a></li>
<li><b>Watch for long argument lists</b>. Method calls then become difficult to
write, read, and maintain. Instead, try to move the method to a class where it
is (more) appropriate, and/or pass objects in as arguments. <a
href="mailto:TIJ3@MindView.net?Subject=[TIJ3]AppendC_2846" title="Send BackTalk
Comment"></a></li>
<li><b>Don&#146;t repeat yourself</b>. If a piece of code is recurring in many
methods in derived classes, put that code into a single method in the base class
and call it from the derived-class methods. Not only do you save code space, but
you provide for easy propagation of changes. Sometimes the discovery of this
common code will add valuable functionality to your interface. A simpler version
of this guideline also occurs without inheritance: If a class has methods that
repeat code, factor that code into a common method and call it from the other
methods. <a
href="mailto:TIJ3@MindView.net?Subject=[TIJ3]AppendC_2847" title="Send BackTalk
Comment"></a></li>
<li><b>Watch for <i>switch</i> statements or chained <i>if-else</i> clauses</b>.
This is typically an indicator of <i>type-check coding</i>, which means that you
are choosing what code to execute based on some kind of type information (the
exact type may not be obvious at first). You can usually replace this kind of
code with inheritance and polymorphism; a polymorphic method call will perform
the type checking for you and allow for more reliable and easier extensibility.
<a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]AppendC_2848"
title="Send BackTalk Comment"></a></li>
<li><b>From a design standpoint, look for and separate things that change from
things that stay the same</b>. That is, search for the elements in a system that
you might want to change without forcing a redesign, then encapsulate those
elements in classes. You can learn much more about this concept in <i>Thinking
in Patterns (with Java)</i> at <i>www.BruceEckel.com</i>. <a
href="mailto:TIJ3@MindView.net?Subject=[TIJ3]AppendC_2849" title="Send BackTalk
Comment"></a></li>
<li><b>Don&#146;t extend fundamental functionality by subclassing</b>. If an
interface element is essential to a class it should be in the base class, not
added during derivation. If you&#146;re adding methods by inheriting, perhaps
you should rethink the design. <a
href="mailto:TIJ3@MindView.net?Subject=[TIJ3]AppendC_2850" title="Send BackTalk
Comment"></a></li>
<li><b>Less is more</b>. Start with a minimal interface to a class, as small and
simple as you need to solve the problem at hand, but don&#146;t try to
anticipate all the ways that your class <i>might</i> be used. As the class is
used, you&#146;ll discover ways you must expand the interface. However, once a
class is in use, you cannot shrink the interface without breaking client code.
If you need to add more methods, that&#146;s fine; it won&#146;t break code.
But even if new methods replace the functionality of old ones, leave the
existing interface alone (you can combine the functionality in the underlying
implementation if you want). If you need to expand the interface of an existing
method by adding more arguments, create an overloaded method with the new
arguments; this way, you won&#146;t disturb any calls to the existing method.
<a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]AppendC_2851"
title="Send BackTalk Comment"></a></li>
<li><b>Read your classes aloud to make sure they&#146;re logical</b>. Refer to
the relationship between a base class and derived class as &#147;is-a&#148;
and member objects as &#147;has-a.&#148; <a
href="mailto:TIJ3@MindView.net?Subject=[TIJ3]AppendC_2852" title="Send BackTalk
Comment"></a></li>
<li><b>When deciding between inheritance and composition, ask if you need to
upcast to the base type</b>. If not, prefer composition (member objects) to
inheritance. This can eliminate the perceived need for multiple base types. If
you inherit, users will think they are supposed to upcast. <a
href="mailto:TIJ3@MindView.net?Subject=[TIJ3]AppendC_2853" title="Send BackTalk
Comment"></a></li>
<li><b>Use fields for variation in value, and method overriding for variation in
behavior</b>. That is, if you find a class that uses state variables along with
methods that switch behavior based on those variables, you should probably
redesign it to express the differences in behavior within subclasses and
overridden methods. <a
href="mailto:TIJ3@MindView.net?Subject=[TIJ3]AppendC_2854" title="Send BackTalk
Comment"></a></li>
<li><b>Watch for overloading</b>. A method should not conditionally execute code
based on the value of an argument. In this case, you should create two or more
overloaded methods instead. <a
href="mailto:TIJ3@MindView.net?Subject=[TIJ3]AppendC_2855" title="Send BackTalk
Comment"></a></li>
<li><b>Use exception hierarchies</b>&#151;preferably derived from specific
appropriate classes in the standard Java exception hierarchy. The person
catching the exceptions can then write handlers for the specific types of
exceptions, followed by handlers for the base type. If you add new derived
exceptions, existing client code will still catch the exception through the base
type. <a
href="mailto:TIJ3@MindView.net?Subject=[TIJ3]AppendC_2856" title="Send BackTalk
Comment"></a></li>
<li><b>Sometimes simple aggregation does the job</b>. A &#147;passenger comfort
system&#148; on an airline consists of disconnected elements: seat, air
conditioning, video, etc., and yet you need to create many of these in a plane.
Do you make private members and build a whole new interface? No&#151;in this
case, the components are also part of the public interface, so you should create
public member objects. Those objects have their own private implementations,
which are still safe. Be aware that simple aggregation is not a solution to be
used often, but it does happen. <a
href="mailto:TIJ3@MindView.net?Subject=[TIJ3]AppendC_2857" title="Send BackTalk
Comment"></a></li>
<li><b>Consider the perspective of the client programmer and the person
maintaining the code</b>. Design your class to be as obvious as possible to use.
Anticipate the kind of changes that will be made, and design your class so that
those changes will be easy. <a
href="mailto:TIJ3@MindView.net?Subject=[TIJ3]AppendC_2858" title="Send BackTalk
Comment"></a></li>
<li><b>Watch out for &#147;giant object syndrome.&#148;</b> This is often an
affliction of procedural programmers who are new to OOP and who end up writing a
procedural program and sticking it inside one or two giant objects. With the
exception of application frameworks, objects represent concepts in your
application, not the application itself. <a
href="mailto:TIJ3@MindView.net?Subject=[TIJ3]AppendC_2859" title="Send BackTalk
Comment"></a></li>
<li><b>If you must do something ugly, at least localize the ugliness inside a
class</b>. <a
href="mailto:TIJ3@MindView.net?Subject=[TIJ3]AppendC_2860" title="Send BackTalk
Comment"></a></li>
<li><b>If you must do something nonportable, make an abstraction for that
service and localize it within a class</b>. This extra level of indirection
prevents the nonportability from being distributed throughout your program.
(This idiom is embodied in the <i>Bridge </i>Pattern, among others). 
><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]AppendC_2861"
title="Send BackTalk Comment"></a></li>
<li><b>Objects should not simply hold some data</b>. They should also have
well-defined behaviors. (Occasionally, &#147;data objects&#148; are
appropriate, but only when used expressly to package and transport a group of
items when a generalized container is innappropriate.) <a
href="mailto:TIJ3@MindView.net?Subject=[TIJ3]AppendC_2862" title="Send BackTalk
Comment"></a></li>
<li><b>Choose composition first when creating new classes from existing
classes</b>. You should only use inheritance if it is required by your design.
If you use inheritance where composition will work, your designs will become
needlessly complicated. <a
href="mailto:TIJ3@MindView.net?Subject=[TIJ3]AppendC_2863" title="Send BackTalk
Comment"></a></li>
<li><b>Use inheritance and method overriding to express differences in behavior,
and fields to express variations in state</b>. An extreme example of what not to
do is to inherit different classes to represent colors instead of using a
&#147;color&#148; field. <a
href="mailto:TIJ3@MindView.net?Subject=[TIJ3]AppendC_2864" title="Send BackTalk
Comment"></a></li>
<li><b>Watch out for <i>variance</i></b>. Two semantically different objects may
have identical actions, or responsibilities, and there is a natural temptation
to try to make one a subclass of the other just to benefit from inheritance.
This is called variance, but there&#146;s no real justification to force a
superclass/subclass relationship where it doesn&#146;t exist. A better solution
is to create a general base class that produces an interface for both as derived
classes; it requires a bit more space, but you still benefit from inheritance
and will probably make an important discovery about the design. 
><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]AppendC_2865"
title="Send BackTalk Comment"></a></li>
<li><b>Watch out for <i>limitation</i> during inheritance</b>. The clearest
designs add new capabilities to inherited ones. A suspicious design removes old
capabilities during inheritance without adding new ones. But rules are made to
be broken, and if you are working from an old class library, it may be more
efficient to restrict an existing class in its subclass than it would be to
restructure the hierarchy so your new class fits in where it should, above the
old class. <a
href="mailto:TIJ3@MindView.net?Subject=[TIJ3]AppendC_2866" title="Send BackTalk
Comment"></a></li>
<li><b>Use design patterns to eliminate &#147;naked functionality.&#148;</b>
That is, if only one object of your class should be created, don&#146;t bolt
ahead to the application and write a comment &#147;Make only one of
these.&#148; Wrap it in a singleton. If you have a lot of messy code in your
main program that creates your objects, look for a creational pattern like a
factory method in which you can encapsulate that creation. Eliminating
&#147;naked functionality&#148; will not only make your code much easier to
understand and maintain, but it will also make it more bulletproof against the
well-intentioned maintainers that come after you. <a
href="mailto:TIJ3@MindView.net?Subject=[TIJ3]AppendC_2867" title="Send BackTalk
Comment"></a></li>
<li><b>Watch out for &#147;analysis paralysis.&#148;</b> Remember that you
must usually move forward in a project before you know everything, and that
often the best and fastest way to learn about some of your unknown factors is to
go to the next step rather than trying to figure it out in your head. You
can&#146;t know the solution until you <i>have</i> the solution. Java has
built-in firewalls; let them work for you. Your mistakes in a class or set of
classes won&#146;t destroy the integrity of the whole system. 
><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]AppendC_2868"
title="Send BackTalk Comment"></a></li>
<li><b>When you think you&#146;ve got a good analysis, design, or
implementation, do a walkthrough</b>. Bring someone in from outside your
group&#151;this doesn&#146;t have to be a consultant, but can be someone from
another group within your company. Reviewing your work with a fresh pair of eyes
can reveal problems at a stage when it&#146;s much easier to fix them, and more
than pays for the time and money &#147;lost&#148; to the walkthrough process.
<a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]AppendC_2869"
title="Send BackTalk Comment"></a></li></ol><h2>
<a name="_Toc24776014"></a><a name="Heading25795"></a>Implementation</h2>
<ol>
<li><b>In general, follow the Sun coding conventions</b>. These are available
at<br><i>java.sun.com/docs/codeconv/index.html</i> (the code in this book
follows these conventions as much as I was able). These are used for what
constitutes arguably the largest body of code that the largest number of Java
programmers will be exposed to. If you doggedly stick to the coding style
you&#146;ve always used, you will make it harder for your reader. Whatever
coding conventions you decide on, ensure that they are consistent throughout the
project. There is a free tool to automatically reformat Java code at
<i>http://jalopy.sourceforge.net.</i> You can find a free style checker at
<i>http://jcsc.sourceforge.net</i>. <a
href="mailto:TIJ3@MindView.net?Subject=[TIJ3]AppendC_2870" title="Send BackTalk
Comment"></a></li>
<li><b>Whatever coding style you use, it really does make a difference if your
team (and even better, your company) standardizes on it</b>. This means to the
point that everyone considers it fair game to fix someone else&#146;s coding
style if it doesn&#146;t conform. The value of standardization is that it takes
less brain cycles to parse the code, so that you can focus more on what the code
means. <a
href="mailto:TIJ3@MindView.net?Subject=[TIJ3]AppendC_2871" title="Send BackTalk
Comment"></a></li>
<li><b>Follow standard capitalization rules</b>. Capitalize the first letter of
class names. The first letter of fields, methods, and objects (references)
should be lowercase. All identifiers should run their words together, and
capitalize the first letter of all intermediate words. For
example:<br><b>ThisIsAClassName</b><br><b>thisIsAMethodOrFieldName</b><br>Capitalize
<i>all</i> the letters (and use underscore word separators) of <b>static</b>
<b>final</b> primitive identifiers that have constant initializers in their
definitions. This indicates that they are compile-time constants.<br><b>Packages
are a special case</b>&#151;they are all lowercase letters, even for
intermediate words. The domain extension (com, org, net, edu, etc.) should also
be lowercase. (This was a change between Java 1.1 and Java 2.) 
><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]AppendC_2872"
title="Send BackTalk Comment"></a></li>
<li><b>Don&#146;t create your own &#147;decorated&#148; private field
names</b>. This is usually seen in the form of prepended underscores and
characters. Hungarian notation is the worst example of this, where you attach
extra characters that indicate data type, use, location, etc., as if you were
writing assembly language and the compiler provided no extra assistance at all.
These notations are confusing, difficult to read, and unpleasant to enforce and
maintain. Let classes and packages do the name scoping for you. If you feel that
you must decorate your names to prevent confusion, your code is probably too
confusing anyway and should be simplified. <a
href="mailto:TIJ3@MindView.net?Subject=[TIJ3]AppendC_2873" title="Send BackTalk
Comment"></a></li>
<li><b>Follow a &#147;canonical form&#148; </b>when creating a class for
general-purpose use. Include definitions for <b>equals(&#160;)</b>,
<b>hashCode(&#160;)</b>, <b>toString(&#160;)</b>, <b>clone(&#160;)</b>
(implement <b>Cloneable</b>, or choose some other object copying approach, like
serialization), and implement <b>Comparable </b>and <b>Serializable</b>. 
><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]AppendC_2874"
title="Send BackTalk Comment"></a></li>
<li><b>Use the JavaBeans &#147;get,&#148; &#147;set,&#148; and
&#147;is&#148; naming conventions</b> for methods that read and change
<b>private</b> fields, even if you don&#146;t think you&#146;re making a
JavaBean at the time. Not only does it make it easy to use your class as a Bean,
but it&#146;s a standard way to name these kinds of methods, so it will be more
easily understood by the reader. <a
href="mailto:TIJ3@MindView.net?Subject=[TIJ3]AppendC_2875" title="Send BackTalk
Comment"></a></li>
<li><b>For each class you create, include JUnit tests for that class</b> (see
<i>www.junit.org</i>, and examples in Chapter 15). You don&#146;t need to
remove the test code to use the class in a project, and if you make any changes,
you can easily rerun the tests. This code also provides examples of how to use
your class. <a
href="mailto:TIJ3@MindView.net?Subject=[TIJ3]AppendC_2876" title="Send BackTalk
Comment"></a></li>
<li><b>Sometimes you need to inherit in order to access <i>protected</i> members
of the base class</b>. This can lead to a perceived need for multiple base
types. If you don&#146;t need to upcast, first derive a new class to perform
the protected access. Then make that new class a member object inside any class
that needs to use it, rather than inheriting. <a
href="mailto:TIJ3@MindView.net?Subject=[TIJ3]AppendC_2877" title="Send BackTalk
Comment"></a></li>
<li><b>Avoid the use of <i>final</i> methods for efficiency purposes</b>. Use
<b>final </b>only when the program is running, but not fast enough, and your
profiler has shown you that a method invocation is the bottleneck. 
><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]AppendC_2878"
title="Send BackTalk Comment"></a></li>
<li><b>If two classes are associated with each other in some functional way
(such as containers and iterators), try to make one an inner class of the
other</b>. This not only emphasizes the association between the classes, but it
allows the class name to be reused within a single package by nesting it within
another class. The Java containers library does this by defining an inner
<b>Iterator</b> class inside each container class, thereby providing the
containers with a common interface. The other reason you&#146;ll want to use an
inner class is as part of the <b>private </b>implementation. Here, the inner
class is beneficial for implementation hiding rather than the class association
and prevention of namespace pollution noted above. <a
href="mailto:TIJ3@MindView.net?Subject=[TIJ3]AppendC_2879" title="Send BackTalk
Comment"></a></li>
<li><b>Anytime you notice classes that appear to have high coupling with each
other, consider the coding and maintenance improvements you might get by using
inner classes</b>. The use of inner classes will not uncouple the classes, but
rather make the coupling explicit and more convenient. <a
href="mailto:TIJ3@MindView.net?Subject=[TIJ3]AppendC_2880" title="Send BackTalk
Comment"></a></li>
<li><b>Don&#146;t fall prey to premature optimization</b>. This way lies
madness. In particular, don&#146;t worry about writing (or avoiding) native
methods, making some methods <b>final</b>, or tweaking code to be efficient when
you are first constructing the system. Your primary goal should be to prove the
design. Even if the design requires a certain efficiency, <i>first make it work,
then make it fast</i>. <a
href="mailto:TIJ3@MindView.net?Subject=[TIJ3]AppendC_2881" title="Send BackTalk
Comment"></a></li>
<li><b>Keep scopes as small as possible so the visibility and lifetime of your
objects are as small as possible</b>. This reduces the chance of using an object
in the wrong context and hiding a difficult-to-find bug. For example, suppose
you have a container and a piece of code that iterates through it. If you copy
that code to use with a new container, you may accidentally end up using the
size of the old container as the upper bound of the new one. If, however, the
old container is out of scope, the error will be caught at compile time. 
><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]AppendC_2882"
title="Send BackTalk Comment"></a></li>
<li><b>Use the containers in the standard Java library</b>. Become proficient
with their use and you&#146;ll greatly increase your productivity. Prefer
<b>ArrayList</b> for sequences, <b>HashSet</b> for sets, <b>HashMap</b> for
associative arrays, and <b>LinkedList</b> for stacks (rather than <b>Stack</b>,
although you may want to create an adapter to give a stack interface) and queues
(which may also warrant an adapter, as shown in this book). When you use the
first three, you should upcast to <b>List</b>, <b>Set</b>, and <b>Map</b>,
respectively, so that you can easily change to a different implementation if
necessary. <a
href="mailto:TIJ3@MindView.net?Subject=[TIJ3]AppendC_2883" title="Send BackTalk
Comment"></a></li>
<li><b>For a program to be robust, each component must be robust</b>. Use all
the tools provided by Java&#151;access control, exceptions, type checking,
synchronization, and so on&#151;in each class you create. That way you can
safely move to the next level of abstraction when building your system. 
><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]AppendC_2884"
title="Send BackTalk Comment"></a></li>
<li><b>Prefer compile-time errors to run-time errors</b>. Try to handle an error
as close to the point of its occurrence as possible. Catch any exceptions in the
nearest handler that has enough information to deal with them. Do what you can
with the exception at the current level; if that doesn&#146;t solve the
problem, rethrow the exception. <a
href="mailto:TIJ3@MindView.net?Subject=[TIJ3]AppendC_2885" title="Send BackTalk
Comment"></a></li>
<li><b>Watch for long method definitions</b>. Methods should be brief,
functional units that describe and implement a discrete part of a class
interface. A method that is long and complicated is difficult and expensive to
maintain, and is probably trying to do too much all by itself. If you see such a
method, it indicates that, at the least, it should be broken up into multiple
methods. It may also suggest the creation of a new class. Small methods will
also foster reuse within your class. (Sometimes methods must be large, but they
should still do just one thing.) <a
href="mailto:TIJ3@MindView.net?Subject=[TIJ3]AppendC_2886" title="Send BackTalk
Comment"></a></li>
<li><b>Keep things as &#147;<i>private</i> as possible</b>.<b>&#148;</b> Once
you publicize an aspect of your library (a method, a class, a field), you can
never take it out. If you do, you&#146;ll wreck somebody&#146;s existing code,
forcing them to rewrite and redesign. If you publicize only what you must, you
can change everything else with impunity, and since designs tend to evolve, this
is an important freedom. In this way, implementation changes will have minimal
impact on derived classes. Privacy is especially important when dealing with
multithreading&#151;only <b>private</b> fields can be protected against
un-<b>synchronized</b> use. <a
href="mailto:TIJ3@MindView.net?Subject=[TIJ3]AppendC_2887" title="Send BackTalk
Comment"></a><br>Classes with package access should still have
<b>private</b> fields, but it usually makes sense to give the methods of package
access rather than making them <b>public</b>. <a
href="mailto:TIJ3@MindView.net?Subject=[TIJ3]A0464" title="Send BackTalk
Comment"></a></li>
<li><b>Use comments liberally, and use the <i>javadoc</i> comment-documentation
syntax to produce your program documentation</b>. However, the comments should
add geniune meaning to the code; comments that only reiterate what the code is
clearly expressing are annoying. Note that the typical verbose detail of Java
class and method names reduce the need for some comments. <a
href="mailto:TIJ3@MindView.net?Subject=[TIJ3]AppendC_2888" title="Send BackTalk
Comment"></a></li>
<li><b>Avoid using &#147;magic numbers&#148;</b>&#151;which are numbers
hard-wired into code. These are a nightmare if you need to change them, since
you never know if &#147;100&#148; means &#147;the array size&#148; or
&#147;something else entirely.&#148; Instead, create a constant with a
descriptive name and use the constant identifier throughout your program. This
makes the program easier to understand and much easier to maintain. 
><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]AppendC_2889"
title="Send BackTalk Comment"></a></li>
<li><b>When creating constructors, consider exceptions</b>. In the best case,
the constructor won&#146;t do anything that throws an exception. In the
next-best scenario, the class will be composed and inherited from robust classes
only, so they will need no cleanup if an exception is thrown. Otherwise, you
must clean up composed classes inside a <b>finally</b> clause. If a constructor
must fail, the appropriate action is to throw an exception, so the caller
doesn&#146;t continue blindly, thinking that the object was created correctly.
<a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]AppendC_2890"
title="Send BackTalk Comment"></a></li>
<li><b>Inside constructors, do only what is necessary to set the object into the
proper state</b>. Actively avoid calling other methods (except for <b>final</b>
methods), because those methods can be overridden by someone else to produce
unexpected results during construction. (See Chapter 7 for details.) Smaller,
simpler constructors are less likely to throw exceptions or cause problems.
<a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]AppendC_2897"
title="Send BackTalk Comment"></a></li>
<li><b>If your class requires any cleanup when the client programmer is finished
with the object, place the cleanup code in a single, well-defined method</b>,
with a name like <b>dispose(&#160;)</b> that clearly suggests its purpose. In
addition, place a <b>boolean</b> flag in the class to indicate whether
<b>dispose(&#160;)</b> has been called so that <b>finalize(&#160;)</b> can check
for &#147;the termination condition&#148; (see Chapter 4). <a
href="mailto:TIJ3@MindView.net?Subject=[TIJ3]AppendC_2891" title="Send BackTalk
Comment"></a></li>
<li><b>The responsibility of <i>finalize(&#160;)</i> can only be to verify
&#147;the termination condition&#148; of an object for debugging</b>. (See
Chapter 4.) In special cases, it might be needed to release memory that would
not otherwise be released by the garbage collector. Since the garbage collector
might not get called for your object, you cannot use <b>finalize(&#160;) </b>to
perform necessary cleanup. For that you must create your own
<b>dispose(&#160;)</b> method. In the <b>finalize(&#160;)</b> method for the
class, check to make sure that the object has been cleaned up and throw a class
derived from <b>RuntimeException</b> if it hasn&#146;t, to indicate a
programming error. Before relying on such a scheme, ensure that
<b>finalize(&#160;) </b>works on your system. (You might need to call
<b>System.gc(&#160;)</b> to ensure this behavior.) <a
href="mailto:TIJ3@MindView.net?Subject=[TIJ3]AppendC_2892" title="Send BackTalk
Comment"></a></li>
<li><b>If an object must be cleaned up (other than by garbage collection) within
a particular scope, use the following idiom:</b> initialize the object and, if
successful, immediately enter a <b>try</b> block with a <b>finally</b> clause
that performs the cleanup. <a
href="mailto:TIJ3@MindView.net?Subject=[TIJ3]AppendC_2893" title="Send BackTalk
Comment"></a></li>
<li><b>When overriding <i>finalize(&#160;)</i> during inheritance, remember to
call <i>super.finalize(&#160;)</i></b>. (This is not necessary if <b>Object</b>
is your immediate superclass.) You should call <b>super.finalize(&#160;)</b> as
the <i>final</i> act of your overridden <b>finalize(&#160;)</b> rather than the
first, to ensure that base-class components are still valid if you need them.
<a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]AppendC_2894"
title="Send BackTalk Comment"></a></li>
<li><b>When you are creating a fixed-size container of objects, transfer them to
an array</b>, especially if you&#146;re returning this container from a method.
This way you get the benefit of the array&#146;s compile-time type checking,
and the recipient of the array might not need to cast the objects in the array
in order to use them. Note that the base-class of the containers library,
<b>java.util.Collection</b>, has two <b>toArray(&#160;)</b> methods to
accomplish this. <a
href="mailto:TIJ3@MindView.net?Subject=[TIJ3]AppendC_2895" title="Send BackTalk
Comment"></a></li>
<li><b>Choose <i>interfaces</i> over <i>abstract</i> classes</b>. If you know
something is going to be a base class, your first choice should be to make it an
<b>interface</b>, and only if you&#146;re forced to have method definitions or
member variables should you change it to an <b>abstract</b> class. An
<b>interface </b>talks about what the client wants to do, while a class tends to
focus on (or allow) implementation details. <a
href="mailto:TIJ3@MindView.net?Subject=[TIJ3]AppendC_2896" title="Send BackTalk
Comment"></a></li>
<li><b>To avoid a highly frustrating experience, make sure that there is only
one unpackaged class of each name anywhere in your classpath</b>. Otherwise, the
compiler can find the identically-named other class first, and report error
messages that make no sense. If you suspect that you are having a classpath
problem, try looking for <b>.class</b> files with the same names at each of the
starting points in your classpath. Ideally, put all your classes within
packages. <a
href="mailto:TIJ3@MindView.net?Subject=[TIJ3]AppendC_2898" title="Send BackTalk
Comment"></a></li>
<li><b>Watch out for accidental overloading</b>. If you attempt to override a
base-class method and you don&#146;t quite get the spelling right, you&#146;ll
end up adding a new method rather than overriding an existing method. However,
this is perfectly legal, so you won&#146;t get any error message from the
compiler or run-time system; your code simply won&#146;t work correctly. 
><a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]AppendC_2899"
title="Send BackTalk Comment"></a></li>
<li><b>Watch out for premature optimization</b>. First make it work, then make
it fast&#151;but only if you must, and only if it&#146;s proven that there is
a performance bottleneck in a particular section of your code. Unless you have
used a profiler to discover a bottleneck, you will probably be wasting your
time. The hidden extra cost of performance tweaks is that your code becomes less
understandable and maintainable. <a
href="mailto:TIJ3@MindView.net?Subject=[TIJ3]AppendC_2900" title="Send BackTalk
Comment"></a></li>
<li><b>Remember that code is read much more than it is written</b>. Clean
designs make for easy-to-understand programs, but comments, detailed
explanations, tests, and examples are invaluable. They will help both you and
everyone who comes after you. If nothing else, the frustration of trying to
ferret out useful information from the JDK documentation should convince you.
<a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]AppendC_2901"
title="Send BackTalk
Comment"></a></li></ol><p class="Numbered"><br></p>
<hr><p class="footnote text"><sup><a name="fn122" href="#fnB122">[122]</a></sup> Explained to me by Andrew Koenig.<br></p>

<!-- <hr><b>Placeholder</b> -->

<hr>

<div align="CENTER"><a href="TIJ319.htm" target="RightFrame"><img src="./prev.gif" alt="Previous " border="0"></a>
<a href="TIJ321.htm" target="RightFrame"><img src="./next.gif" alt="Next " border="0"></a>

<a href="TIJ3_t.htm"><img src="./first.gif" alt="Title Page " border="0"></a>
<a href="TIJ3_i.htm"><img src="./index.gif" alt="Index " border="0"></a>
<a href="TIJ3_c.htm"><img src="./contents.gif" alt="Contents " border="0"></a>
</div>

<a href="mailto:TIJ3@MindView.net?Subject=[TIJ3]AppendC_2834" title="Send BackTalk Comment"></a>

</body>

</html>
